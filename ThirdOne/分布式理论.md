## 分布式理论

### 一致性

​	分布式数据一致性，指的是数据在多份副本中存储时，各副本中的数据是一致的。

### CAP理论

CAP 理论含义是，一个分布式系统不可能同时满足一致性(C:Consistency)，可用性(A: Availability)和分区容错 性(P:Partition tolerance)这三个基本需求，最多只能同时满足其中的2个。

### BASE理论

BASE:全称:Basically Available(基本可用)，Soft state(软状态),和 Eventually consistent(最终一致性)三个 短语的缩写，来自 ebay 的架构师提出。

BASE理论的核心思想是:即使无法做到强一致性，但每个应用都可 以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

### 分布式事务

### 一致性协议2PC

2PC ( Two-Phase Commit缩写)即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段(Prepare phase)、提交阶段(commit phase)，2是指两个阶段，P是指准备阶段，C是指提交阶段。

### 一致性协议3PC

3PC，全称 “three phase commit”，是 2PC 的改进版，将 2PC 的 “提交事务请求” 过程一分为二，共形成了由 CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。

### 一致性算法Paxos

首先一个很重要的概念叫提案(Proposal)。最终要达成一致的value就在提案里。 提案 (Proposal):Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value) 在Paxos算法中，有如下角色:

Client:客户端
 客户端向分布式系统发出 ，并等待 。例如，对分布式文件服务器中文件的写请求。

Proposer:提案发起者 提案者提倡客户请求，试图说服Acceptor对此达成一致，并在发生冲突时充当协调者以推动协议向前发

展 Acceptor:决策者，可以批准提案

Acceptor可以接受(accept)提案;如果某个提案被选定(chosen)，那么该提案里的value就被选定 了

Learners:最终决策的学习者 学习者充当该协议的复制因素

### 一致性算法Raft

Raft 是一种为了管理复制日志的一致性算法。 Raft提供了和Paxos算法相同的功能和性能，但是它的算法结构和Paxos不同。Raft算法更加容易理解并且更容易构

建实际的系统。 Raft将一致性算法分解成了3模块

1. 领导人选举 2. 日志复制 3. 安全性

Raft算法分为两个阶段，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。

## 分布式系统设计策略

### 心跳检测

心跳顾名思义，就是以固定的频率向其他节点汇报当前节点状态的方式。收到心跳，一般可以认为一个节点和现在 的网络拓扑是良好的。当然，心跳汇报时，一般也会携带一些附加的状态、元数据信息，以便管理

### 高可用设计

高可用(High Availability)是系统架构设计中必须考虑的因素之一,通常是指,经过设计来减少系统不能提供服务的时

间.

系统高可用性的常用设计模式包括三种:主备(Master-SLave)、互备(Active-Active)和集群(Cluster)模 式。

### 容错性

容错顾名思义就是IT系统对于错误包容的能力

容错的处理是保障分布式环境下相应系统的高可用或者健壮性

### 负载均衡

其关键在于使用多台集群服务器共同分担计算任务，把网络请求及计算分配到集群可用的不同服务器节

点上，从而达到高可用性及较好的用户操作体验。

## 分布式架构网络通信

### 基本原理

要实现网络机器间的通讯，首先得来看看计算机系统网络通信的基本原理，在底层层面去看，网络通信需要做的就 是将流从一台计算机传输到另外一台计算机，基于传输协议和网络IO来实现，其中传输协议比较出名的有tcp、 udp等等，tcp、udp都是在基于Socket概念上为某类应用场景而扩展出的传输协议，网络IO，主要有bio、nio、 aio三种方式，所有的分布式应用通讯都基于这个原理而实现，只是为了应用的易用，各种语言通常都会提供一些 更为贴近应用易用的应用层协议。

### RPC

RPC全称为remote procedure call，即远程过程调用。

借助RPC可以做到像本地调用一样调用远程服务，是一种进程间的通信方式

RPC架构

一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub 可以理解为存根。

客户端(Client)，服务的调用方。
 客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远 程发送给服务方。
 服务端(Server)，真正的服务提供者。
 服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。

Java RMI 指的是远程方法调用 (Remote Method Invocation),是java原生支持的远程调用 ,采用JRMP(Java Remote Messageing protocol)作为通信协议，可以认为是纯java版本的分布式远程调用解决方案， RMI主要用 于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上，这里的通信可以理解为一个 虚拟机上的对象调用另一个虚拟机上对象的方法。

1.客户端:
 1)存根/桩(Stub):远程对象在客户端上的代理;
 2)远程引用层(Remote Reference Layer):解析并执行远程引用协议; 3)传输层(Transport):发送调用、传递远程方法参数、接收远程方法执行结果。

2.服务端: 1)骨架(Skeleton):读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值;
 2)远程引用层(Remote Reference Layer):处理远程引用后向骨架发送远程方法调用; 3)传输层(Transport):监听客户端的入站连接，接收并转发调用到远程引用层。

3.注册表(Registry):以URL形式注册远程对象，并向客户端回复对远程对象的引用。

### BIO、NIO、AIO

### Netty

### 基于Netty的自定义RPC